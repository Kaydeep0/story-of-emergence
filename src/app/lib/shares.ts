// src/app/lib/shares.ts
// Client-side functions for shares table (encrypted capsules)

import { getSupabaseForWallet } from "./supabase";

// ----- Types -----

/**
 * ShareCapsule represents the encrypted metadata stored in the capsule jsonb column
 */
export type ShareCapsule = {
  id: string;
  kind: string; // for now use "timeline" or "summary"
  payload: any; // placeholder for later specific shapes
};

/**
 * ShareRow matches the shares table columns
 */
export type ShareRow = {
  id: string;
  owner_wallet: string;
  recipient_wallet: string;
  capsule: ShareCapsule;
  created_at: string; // ISO timestamp from server
  revoked_at: string | null; // ISO timestamp from server or null
};

// ----- RPC calls -----

/**
 * List shares created by the owner
 * @param wallet - wallet address of the owner
 * @param opts - pagination options (limit, offset)
 */
export async function listSharesByOwner(
  wallet: string,
  opts: { limit?: number; offset?: number } = {}
): Promise<ShareRow[]> {
  const { limit = 50, offset = 0 } = opts;
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("list_shares_by_owner", {
    w: wallet.toLowerCase(),
    p_limit: limit,
    p_offset: offset,
  });

  if (error) throw error;

  return (data ?? []) as ShareRow[];
}

/**
 * List shares received by the recipient (not revoked)
 * @param wallet - wallet address of the recipient
 * @param opts - pagination options (limit, offset)
 */
export async function listSharesByRecipient(
  wallet: string,
  opts: { limit?: number; offset?: number } = {}
): Promise<ShareRow[]> {
  const { limit = 50, offset = 0 } = opts;
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("list_shares_by_recipient", {
    w: wallet.toLowerCase(),
    p_limit: limit,
    p_offset: offset,
  });

  if (error) throw error;

  return (data ?? []) as ShareRow[];
}

/**
 * Insert a new share
 * @param wallet - wallet address of the owner
 * @param recipientWallet - wallet address of the recipient
 * @param capsule - the encrypted capsule metadata
 * @returns the id of the inserted share
 */
async function insertShare(
  wallet: string,
  recipientWallet: string,
  capsule: ShareCapsule
): Promise<string> {
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("insert_share", {
    p_owner_wallet: wallet.toLowerCase(),
    p_recipient_wallet: recipientWallet.toLowerCase(),
    p_capsule: capsule,
  });

  if (error) throw error;

  return data as string;
}

/**
 * Insert a new share (wrapper for compatibility with page.tsx)
 * @param wallet - wallet address of the owner
 * @param recipientWallet - wallet address of the recipient
 * @param kind - kind of share (e.g., "reflection", "timeline", "summary")
 * @param title - title of the share
 * @param ciphertext - encrypted content
 * @returns the id of the inserted share
 */
export async function rpcInsertShare(
  wallet: string,
  recipientWallet: string,
  kind: string,
  title: string,
  ciphertext: string
): Promise<string> {
  // Construct the capsule for storage
  // The shareId will be generated by the database and returned
  const capsule: ShareCapsule = {
    id: '', // Placeholder - actual id is the row's primary key
    kind,
    payload: {
      title,
      ciphertext,
    },
  };

  return await insertShare(wallet, recipientWallet, capsule);
}

// ----- Placeholder exports for compatibility with other pages -----
// TODO: These functions need to be implemented for the new shares schema

/**
 * Get a share by ID (for capsule opening)
 * @deprecated This function needs to be reimplemented for the new schema
 */
export async function rpcGetShare(
  wallet: string,
  shareId: string
): Promise<ShareRow | null> {
  // TODO: Implement using the new shares table schema
  throw new Error('rpcGetShare not yet implemented for new schema');
}

/**
 * List accepted shares
 * @deprecated This function needs to be reimplemented for the new schema
 */
export async function rpcListAcceptedShares(
  wallet: string,
  sessionKey: CryptoKey,
  opts: { limit?: number; offset?: number } = {}
): Promise<{ items: any[]; nextOffset: number | null }> {
  // TODO: Implement using the new shares table schema
  throw new Error('rpcListAcceptedShares not yet implemented for new schema');
}

/**
 * Insert an accepted share
 * @deprecated This function needs to be reimplemented for the new schema
 */
export async function rpcInsertAcceptedShare(
  wallet: string,
  sessionKey: CryptoKey,
  shareId: string,
  sliceKind: string,
  title: string,
  decryptedPayload: unknown,
  sourceLabel: string
): Promise<string> {
  // TODO: Implement using the new shares table schema
  throw new Error('rpcInsertAcceptedShare not yet implemented for new schema');
}

/**
 * Delete an accepted share
 * @deprecated This function needs to be reimplemented for the new schema
 */
export async function rpcDeleteAcceptedShare(
  wallet: string,
  shareId: string
): Promise<void> {
  // TODO: Implement using the new shares table schema
  throw new Error('rpcDeleteAcceptedShare not yet implemented for new schema');
}
