// src/app/lib/shares.ts
// DEPRECATED: Legacy shares table functions
// 
// ⚠️ DO NOT USE: This file is deprecated.
// Use src/app/lib/wallet_shares.ts instead.
// 
// This file exists only for backward compatibility during migration.
// All new code MUST use wallet_shares table via wallet_shares.ts

import { getSupabaseForWallet } from "./supabase";
import { encryptText, type EncryptionEnvelope } from "../../lib/crypto";

// ----- Types -----

/**
 * ShareCapsule represents the encrypted metadata stored in the capsule jsonb column
 */
export type ShareCapsule = {
  id: string;
  kind: string; // for now use "reflection", "timeline", or "summary"
  payload: {
    title: string;
    ciphertext: string; // base64-encoded ciphertext+tag
    iv: string; // base64-encoded IV (12 bytes)
    version: string; // encryption version, e.g., "v1"
  };
};

/**
 * ShareRow matches the shares table columns
 */
export type ShareRow = {
  id: string;
  owner_wallet: string;
  recipient_wallet: string;
  capsule: ShareCapsule;
  created_at: string; // ISO timestamp from server
  revoked_at: string | null; // ISO timestamp from server or null
};

// ----- RPC calls -----

/**
 * List shares created by the owner
 * @param wallet - wallet address of the owner
 * @param opts - pagination options (limit, offset)
 */
export async function listSharesByOwner(
  wallet: string,
  opts: { limit?: number; offset?: number } = {}
): Promise<ShareRow[]> {
  const { limit = 50, offset = 0 } = opts;
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("list_shares_by_owner", {
    w: wallet.toLowerCase(),
    p_limit: limit,
    p_offset: offset,
  });

  if (error) throw error;

  return (data ?? []) as ShareRow[];
}

/**
 * List shares received by the recipient (not revoked)
 * @param wallet - wallet address of the recipient
 * @param opts - pagination options (limit, offset)
 */
export async function listSharesByRecipient(
  wallet: string,
  opts: { limit?: number; offset?: number } = {}
): Promise<ShareRow[]> {
  const { limit = 50, offset = 0 } = opts;
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("list_shares_by_recipient", {
    w: wallet.toLowerCase(),
    p_limit: limit,
    p_offset: offset,
  });

  if (error) throw error;

  return (data ?? []) as ShareRow[];
}

/**
 * Insert a new share
 * @param wallet - wallet address of the owner
 * @param recipientWallet - wallet address of the recipient
 * @param capsule - the encrypted capsule metadata
 * @returns the id of the inserted share
 */
async function insertShare(
  wallet: string,
  recipientWallet: string,
  capsule: ShareCapsule
): Promise<string> {
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase.rpc("insert_share", {
    p_owner_wallet: wallet.toLowerCase(),
    p_recipient_wallet: recipientWallet.toLowerCase(),
    p_capsule: capsule,
  });

  if (error) throw error;

  return data as string;
}

/**
 * Insert a new share (wrapper for compatibility with page.tsx)
 * @param wallet - wallet address of the owner
 * @param recipientWallet - wallet address of the recipient
 * @param kind - kind of share (e.g., "reflection", "timeline", "summary")
 * @param title - title of the share
 * @param plaintext - plaintext content to encrypt (will be encrypted with sessionKey)
 * @param sessionKey - AES key for encryption
 * @returns the id of the inserted share
 */
export async function rpcInsertShare(
  wallet: string,
  recipientWallet: string,
  kind: string,
  title: string,
  plaintext: string,
  sessionKey: CryptoKey
): Promise<string> {
  // Encrypt the plaintext using the encryption envelope format
  const encrypted = await encryptText(sessionKey, plaintext);

  // Construct the capsule for storage
  // The shareId will be generated by the database and returned
  const capsule: ShareCapsule = {
    id: '', // Placeholder - actual id is the row's primary key
    kind,
    payload: {
      title,
      ciphertext: encrypted.ciphertext,
      iv: encrypted.iv,
      version: encrypted.version,
    },
  };

  return await insertShare(wallet, recipientWallet, capsule);
}

/**
 * Get a share by ID (for capsule opening)
 * Uses direct select with RLS - only returns if recipient matches wallet and not revoked
 * @param wallet - wallet address of the recipient
 * @param shareId - the share ID to fetch
 * @returns ShareRow if found and accessible, null if not found
 * @throws Error if share is revoked or access denied
 */
export async function rpcGetShare(
  wallet: string,
  shareId: string
): Promise<ShareRow> {
  const supabase = getSupabaseForWallet(wallet);

  const { data, error } = await supabase
    .from('shares')
    .select('*')
    .eq('id', shareId)
    .is('revoked_at', null)
    .single();

  if (error) {
    // If not found, throw with a clear message
    if (error.code === 'PGRST116') {
      throw new Error('Share not found or has been revoked');
    }
    throw error;
  }

  if (!data) {
    throw new Error('Share not found or has been revoked');
  }

  // Verify the recipient matches (RLS should handle this, but double-check)
  if (data.recipient_wallet.toLowerCase() !== wallet.toLowerCase()) {
    throw new Error('Share not found or access denied');
  }

  return data as ShareRow;
}

/**
 * Revoke a share by setting revoked_at timestamp
 * @param wallet - wallet address of the owner
 * @param shareId - the share ID to revoke
 * @throws Error if the update fails
 */
export async function rpcRevokeShare(
  wallet: string,
  shareId: string
): Promise<void> {
  const supabase = getSupabaseForWallet(wallet);

  const { error } = await supabase
    .from("shares")
    .update({ revoked_at: new Date().toISOString() })
    .eq("id", shareId);

  if (error) {
    console.error("Failed to revoke share:", error);
    throw error;
  }
}

